import { RESERVED_WORDS } from "../utils/reserved-words";
import type { SvgFile, TsxComponent } from "../types";

export const isInvalidComponentName = (name: string): boolean =>
  !name ||
  name.length === 0 ||
  /^[^a-zA-Z]/.test(name) ||
  RESERVED_WORDS.has(name.toLowerCase()) ||
  name.length > 128;

export const sanitizeComponentName = (filename: string): string => {
  const name = filename
    .replace(/\.svg$/i, "")
    .replace(/[^a-zA-Z0-9]/g, " ")
    .split(" ")
    .filter((word) => word.length > 0)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join("")
    .replace(/^[^a-zA-Z]*/, ""); // Remove leading non-letters

  return isInvalidComponentName(name) ? "" : name;
};

export const replaceColorsWithCurrentColor = (content: string): string => {
  const colorAttributes = [
    "fill",
    "stroke",
    "stop-color",
    "flood-color",
    "lighting-color",
  ];

  // Create regex pattern for color attributes
  const attributePattern = colorAttributes.join("|");

  // Color value patterns
  const colorPatterns = [
    // Hex colors: #000, #000000, #000000ff
    /#[0-9a-fA-F]{3,8}/,
    // RGB/RGBA: rgb(0,0,0), rgba(0,0,0,1)
    /rgba?\s*\(\s*[^)]+\)/,
    // HSL/HSLA: hsl(0,0%,0%), hsla(0,0%,0%,1)
    /hsla?\s*\(\s*[^)]+\)/,
    // Named colors
    /\b(?:black|white|red|green|blue|yellow|orange|purple|pink|brown|gray|grey|cyan|magenta|lime|navy|maroon|olive|teal|silver|aqua|fuchsia|transparent)\b/i,
  ];

  // Combine all color patterns into one regex
  const allColorPattern = new RegExp(
    colorPatterns.map((p) => p.source).join("|"),
    "gi"
  );

  // Replace color attributes
  const regex = new RegExp(
    `(${attributePattern})\\s*=\\s*["']([^"']*?)["']`,
    "gi"
  );

  return content.replace(regex, (match, attribute, value) => {
    if (allColorPattern.test(value)) return `${attribute}="currentColor"`;
    return match; // Return original if no color found
  });
};

export const processSvgContent = (content: string): string => {
  let processed = content;

  // Remove XML declaration and comments
  processed = processed
    .replace(/<\?xml[^>]*\?>/g, "")
    .replace(/<!--[\s\S]*?-->/g, "");

  // Replace colors with currentColor
  processed = replaceColorsWithCurrentColor(processed);

  // Convert kebab-case attributes to camelCase
  processed = processed.replace(
    /([a-zA-Z]+)-([a-zA-Z])/g,
    (_, p1, p2) => p1 + p2.toUpperCase()
  );

  // Handle React-specific attribute name changes
  processed = processed
    .replace(/class=/g, "className=")
    .replace(/for=/g, "htmlFor=");

  // Normalize whitespace and trim
  processed = processed.replace(/\s+/g, " ").trim();

  // Ensure props are spread on svg element
  if (processed.includes("<svg") && !processed.includes("{...props}")) {
    processed = processed.replace(/<svg([^>]*?)>/i, "<React.Fragment>");
  }
  if (processed.includes("</svg>") && !processed.includes("{...props}")) {
    processed = processed.replace("</svg>", "</React.Fragment>");
  }

  return processed;
};

export const createTsxComponent = (svgFile: SvgFile): TsxComponent | null => {
  const componentName = sanitizeComponentName(svgFile.name);
  if (!componentName) return null;

  const processedSvg = processSvgContent(svgFile.content);
  const content = `
  export const ${componentName} = () => (
    ${processedSvg}
  );
  ${componentName}.displayName = "Icon.${componentName}";
`;

  return { name: componentName, content };
};

export const generateHeader = (): string => `
/* Auto-generated by: https://github.com/foundation-ui/svgjsx */\n
import React from 'react';\n
export const Icon = ({ children, ...restProps }: React.ComponentProps<"svg">) => {
  return (
    <svg
      focusable="false"
      aria-hidden="true"
      viewBox="0 0 24 24"
      width={16}
      height={16}
      fill="currentColor"
      {...restProps}
    >
      {children}
    </svg>
  );
}
Icon.displayName = "Icon";\n
`;

export const generateExportList = (componentNames: string[]): string => {
  if (componentNames.length === 0) return "";

  const parentComponentName = "Icon";
  const assignments = componentNames
    .sort() // Sort for consistent output
    .map((name) => `${parentComponentName}.${name} = ${name};`)
    .join("\n");

  return "\n" + assignments;
};
